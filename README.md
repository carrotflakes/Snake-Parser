# Snake Parser

Snake ParserはJavaScript製のパーサジェネレータです。
構造を持ったテキストを入力としてJavaScript上でデータを得たいときに使用します。
データとは、文字列や数値、オブジェクト、配列等で構成された構造的な値を指します。
テキストからデータを取り出すためには、どのように取り出すかを記述した*文法*が必要です。
Snake Parserは文法を入力として、パースするためのJavaScriptコード(パーサ)を出力します。
パーサはjsファイルに書き出すなどして使用できます。

実行はこちら。  
https://carrotflakes.github.io/Snake-Parser/

## 特徴
- パースの結果をどのように取り出すかを文法の中に自然に記述できる
- Packratパーサベース
- 左再帰をそのまま表現可能(ただし、使うと遅い)

## 文法記述法
### 基本
文法は以下のように記述します。

```
// 初期化コード
{
	...
}

// ルールの定義
start = rule1

rule1 "rule" = ...
```

最初に初期化コードを定義します。
初期化コードはパーサに直接埋め込まれるJavaScriptのコードです。
パースを行うたびに最初に実行され、そこで宣言した変数や関数はルール内のJavaScriptを実行する過程で参照できます。
初期化コードが不要であれば `{}` ごと省略することができます。  
次にルールを `ルール名 ["エラー名"] = パージング表現` の形で定義します。
ルール名は `[a-zA-Z_][a-zA-Z0-9_]*` の正規表現を満たすものが使えます。
エラー名はパースが失敗したときに、どこで失敗したのかを表現するために使われます。エラー名は省略可能です。
`start` は最初に呼び出されるルールです。  
文法記述の中ではJavaScriptのように、`//`, `/* */`でコメントを書き込むこともできます。  
文法内のJavaScriptコードでは、この文書で許可していない `$` を含む変数名を使用しないで下さい。パーサ内で使用されている変数と衝突する可能性が有ります。  
初期化コードやパージング表現で使われるJavaScriptコード内では、文字列やコメントの中も含めて `{` と `}` が正しく対応していなければいけません。

### パージング表現
パージング表現とはどのようにパースするか、どのように返り値を生成するかを指示するものです。
パージング表現には入力文字列を消費したり、返り値（データ）を返す機能があります。
また、すべてのパージング表現は成功か失敗かを返します。
以下がパージング表現のすべてです。

#### マッチング
    'A'
    "A"
文字列 `A` と入力文字列を比較します。一致すればその文字列分、入力文字列を消費して成功になります。一致しなければ失敗です。

    [A]
文字の集合を表します。 `[]` で囲まれた文字のいずれかと入力文字列が一致すれば成功です。入力文字列は1文字消費されます。
例えば、 `[abcd]` は `a` `b` `c` `d` の入力で成功します。
また `[abcd]` のように文字コードが連続している場合、 `[a-d]` と書くことが可能です。

    [^A]
`[A]` の否定です。
`[^abcd]` は `a` `b` `c` `d` 以外の入力で成功します。

    .
任意の1文字を消費して成功します。但し、入力文字列が空の場合失敗になります。

#### 量化
    ?A
パージング表現 `A` でのパースを試行します。パースに成功しても失敗しても `?A` は成功です。

    *A
パージング表現 `A` を失敗するまで繰り返します。

    +A
パージング表現 `A` を失敗するまで繰り返します。１回以上成功しないと `+A` は失敗になります。

    n*A
`n` は0以上の数値です。 `A` を `n` 回繰り返したものと同値です。

    n,m*A
`n`、 `m` は `0 <= n <= m` を満たす数値です。
パージング表現 `A` を失敗するまで最大 `m` 回繰り返します。成功回数が `n` 以上ならばこのパースは成功です。

#### 制御
    A
ルール `A` のパージング表現を呼び出します。

    &A
パージング表現 `A` でパースします。パースに成功しても、それによる入力文字列の消費をキャンセルします。
一般的に*肯定先読み*と呼ばれます。

    !A
パージング表現 `A` でパースを試み、成功すれば `!A` は失敗です。失敗すれば `!A` は成功になります。
`A` による入力文字列の消費はありません。
一般的に*否定先読み*と呼ばれます。

    A|B
パージング表現 `A` でパースします。`A` が失敗ならば、 パージング表現 `B` でパースします。

    A B
パージング表現 `A` でパースします。`A` が成功すれば、次にパージング表現 `B` でパースします。

    (...)
括弧の中をひとまとまりに扱います。

#### 返り値
    `A
`A` で消費した文字列を返り値とします。

    {...}
括弧内の `A:B` や `A:=B` をプロパティとするオブジェクトを返り値にします。

    A:B
    "A":B
`{...}` によってオブジェクトが作られるとき、パージング表現 `B` の返り値を、文字列 `A` をキーとしてオブジェクトに格納します。

    A:=B
    "A":="B"
`{...}` によってオブジェクトが作られるとき、文字列 `B` を、文字列 `A` をキーとしてオブジェクトに格納します。

    @A
パージング表現 `A` の中では複数の返り値を返すことが可能です。その複数の返り値を1つの配列として返り値にします。

    A->M
`M` はJavaScriptの関数名です。パージング表現 `A` の返り値を関数 `M` に与えた結果を返り値とします。関数は初期化コード内で宣言された関数とトップレベルで宣言されている関数が使用できます。

    A->{C}
`C` はJavaScriptの関数のボディ部分です。 `function($) {C}` のような関数が存在するとして、パージング表現 `A` の返り値をその関数に与えた結果を返り値とします。
e.g. `A->{return parseInt($);}`

    A-?M
`M` はJavaScriptの関数名です。パージング表現 `A` の返り値を関数 `M` に与えた結果が偽と評価されるとき `A-?M` は失敗になります。関数は初期化コード内で宣言された関数とトップレベルで宣言されている関数が使用できます。

    A-?{C}
`C` はJavaScriptの関数のボディ部分です。 `function($) {C}` のような関数が存在するとして、パージング表現 `A` の返り値をその関数に与えた結果が偽と評価されるとき `A-?{C}` は失敗になります。

    A-|
パージング表現 `A` の返り値を捨てます。

    \123
    \"Hello"
    \true
    \null
numeric や string 、 boolean 、 null などの値をそのまま返り値とします。

#### その他
    $pos
    $input
    $row
    $column
未実装


## 文法記述例
次の文法は `+` と `*` と `()` と整数で構成された数式を計算します。
`(1+2)*3` を入力すると `9` が出力されます。

```
{
  function additive($) {
    return $.left + $.right;
  }
  function multiplicative($) {
    return $.left * $.right;
  }
  function integer($) {
    return +$;
  }
}

start
  = additive

additive
  = {
      left:multiplicative
      "+"
      right:additive
    } -> additive
  | multiplicative

multiplicative
  = {
      left:primary
      "*"
      right:multiplicative
    } -> multiplicative
  | primary

primary
  = integer
  | "(" additive ")"

integer
  = `+[0-9] -> integer
```
